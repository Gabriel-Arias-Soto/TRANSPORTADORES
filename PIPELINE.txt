---

# ğŸš€ **PIPELINE ACTUAL DE ANÃLISIS DE TRANSPORTADORES**

---

## **FASE 1: PreparaciÃ³n y organizaciÃ³n**

âœ… Definir familias de interÃ©s: `HMA`, `PIP`, `TIP`, `NIP`, `NRAMP`, `PCS`, `MT-L`
âœ… Estructurar carpetas:

```
TRANSPORTADORES/
â”‚
â”œâ”€â”€ data_proteomas/
â”‚   â”œâ”€â”€ salix_purpurea/
â”‚   â”œâ”€â”€ eucalyptus_globulus/
â”‚   â”œâ”€â”€ ...
â”‚
â”œâ”€â”€ data_proteomas/analisis_filogenia/
â”‚   â”œâ”€â”€ fastas_combinados/         â†’ Secuencias combinadas por familia
â”‚   â”œâ”€â”€ alineamientos/             â†’ Alineamientos por familia y global
â”‚   â”œâ”€â”€ hmmscan_resultados/        â†’ Salida de hmmscan
â”‚   â”œâ”€â”€ clustering/                â†’ Mapas de calor y dendrogramas
```

---

## **FASE 2: Alineamiento de secuencias**

âœ… Usar **MAFFT** para alinear las secuencias de cada familia por separado
âœ… Generar archivos tipo:
`HMA_alineado.faa`
`PIP_alineado.faa`
...

âœ… Concatenar los alineamientos en un global:
`transportadores_alineado.faa`

---

## **FASE 3: Similitud global y clÃºster de secuencias**

âœ… Correr el script `heatmap_global_de_similitud_de_transportadores.py`
âœ… Detectar que **las secuencias deben tener el mismo largo** en el archivo concatenado (propio de un alineamiento)
âœ… Mejorare la visualizaciÃ³n:

* Limpiar los IDs de las secuencias (sin descripciones largas)
* Ajustar tÃ­tulos y posiciones de colorbar
* Mejorar el estilo del clustermap por familia

---

## **FASE 4: BÃºsqueda de dominios con HMMER**

âœ… Correr **hmmscan** para cada familia contra la base Pfam-A:

```
hmmscan --tblout <familia>_pfam.tblout Pfam-A.hmm <familia>_combinado.faa
```

âœ… Los `.tblout` quedaron en:
`TRANSPORTADORES/data_proteomas/analisis_filogenia/hmmscan_resultados/`

---

## **FASE 5: Primeros pasos de anÃ¡lisis de dominios**

âœ… Preparar un Rscript inspirado en lo que hice para ELIP
âœ… Definir que necesitas:

* Contar dominios por proteÃ­na
* Contar dominios por especie
* Distribuciones de score
* UpSetPlot de presencia/ausencia

âœ… Consolidar los `.tblout` en un Ãºnico CSV limpio para poder correr ese anÃ¡lisis



# ğŸ¯ **Lo que viene, paso a paso**


grÃ¡fico en R sobre ese CSV:

   * Dominios por proteÃ­na
   * Dominios por especie
   * DistribuciÃ³n de scores
   * UpSetPlot



POR DELANTE

3. **AnÃ¡lisis opcional avanzado:**

   * PCA de presencia/ausencia
   * Red de co-ocurrencia de dominios



=====================
=====================
====================
====================

USO DE LLM DURO

=========================


Pipeline ordenado, completo y prÃ¡ctico, basado en ELIPs, pero adaptado a transportadores, integrando:

âœ… Limpieza previa de .tblout si es necesario
âœ… AnÃ¡lisis del nÃºmero de dominios por proteÃ­na
âœ… Conteo de dominios por especie (lo que pediste nuevo)
âœ… DistribuciÃ³n de scores
âœ… UpSetPlot final

ğŸ”¬ PIPELINE PARA ANÃLISIS DE DOMINIOS TRANSPORTADORES POST-HMMSCAN
PASO 0: Requisitos previos
Ya tienes los .tblout de hmmscan generados para cada familia en:

bash
Copiar
Editar
/mnt/c/Users/gabri/Documents/SCRIPTS_ESTUDIO_PYTHON/TRANSPORTADORES/data_proteomas/analisis_filogenia/hmmscan_resultados/
Ejemplos:
HMA_pfam.tblout
PIP_pfam.tblout
...hasta los 7 .tblout

PASO 1: Combinar y limpiar los .tblout en un solo CSV procesable
Tienes que usar un script en Python para convertir los .tblout a CSV, extrayendo al menos:

query_name (nombre de la proteÃ­na)

target_name (dominio Pfam identificado)

score_full

E-value_full

Este script lo puedes llamar, por ejemplo, procesar_tblout_pfam.py. Ya te lo habÃ­a sugerido, si quieres te lo dejo listo nuevamente.

ğŸ”§ Salida esperada:
Un archivo Ãºnico:
pfam_transportadores.csv

PASO 2: AnÃ¡lisis en R â€” Dominio por proteÃ­na y por especie
Correr un script similar al de ELIP, pero con estas modificaciones:

âœ¨ Limpieza e incorporaciÃ³n de especie y familia desde query_name
Si tus IDs son como:
ATH_HMA_001|algo|algo

Entonces:

Especie = "ATH"

Familia = "HMA"

ğŸ”¥ Pipeline en R:
r
Copiar
Editar
rm(list = ls())
cat("\014")

# -----------------------
# Cargar librerÃ­as
# -----------------------
required_packages <- c("readr", "dplyr", "ggplot2", "tidyr", "forcats", "UpSetR")
new_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if(length(new_packages)) install.packages(new_packages)
lapply(required_packages, library, character.only = TRUE)

# -----------------------
# Leer y preparar datos
# -----------------------
file_path <- "C:/Users/gabri/Documents/SCRIPTS_ESTUDIO_PYTHON/TRANSPORTADORES/data_proteomas/analisis_filogenia/hmmscan_resultados/pfam_transportadores.csv"

pfam_data <- read_csv(file_path, show_col_types = FALSE) %>%
  mutate(
    Especie = sub("_.*", "", query_name),
    Familia = sub(".*_(.*)_.*", "\\1", query_name)
  )

# -----------------------
# 1. NÃºmero de dominios Ãºnicos por proteÃ­na
# -----------------------
dominios_por_proteina <- pfam_data %>%
  group_by(query_name) %>%
  summarise(n_dominios = n_distinct(target_name), .groups = "drop") %>%
  arrange(desc(n_dominios))

ggplot(dominios_por_proteina, aes(x = n_dominios)) +
  geom_histogram(binwidth = 1, fill = "#0072B2", alpha = 0.8) +
  geom_vline(aes(xintercept = mean(n_dominios)), color = "orange", linetype = "dashed") +
  labs(title = "DistribuciÃ³n de dominios Pfam por proteÃ­na", x = "NÂ° de dominios Ãºnicos", y = "Frecuencia") +
  theme_minimal()

# -----------------------
# 2. Conteo de dominios por especie
# -----------------------
conteo_dominios <- pfam_data %>%
  group_by(Especie, target_name) %>%
  summarise(n_veces = n(), .groups = "drop") %>%
  arrange(Especie, desc(n_veces))

print(conteo_dominios)

# -----------------------
# 3. Top dominios globales
# -----------------------
top_dominios <- pfam_data %>%
  count(target_name, sort = TRUE, name = "n_proteinas") %>%
  mutate(porcentaje = n_proteinas / nrow(dominios_por_proteina) * 100)

ggplot(top_dominios %>% head(15), aes(x = fct_reorder(target_name, n_proteinas), y = n_proteinas, fill = porcentaje)) +
  geom_col() +
  coord_flip() +
  scale_fill_gradient(low = "skyblue", high = "darkblue") +
  labs(title = "Top 15 dominios mÃ¡s frecuentes", x = "Dominio", y = "NÂ° de proteÃ­nas", fill = "%") +
  theme_minimal()

# -----------------------
# 4. UpSetPlot de presencia/ausencia
# -----------------------
binaria <- pfam_data %>%
  mutate(presente = 1) %>%
  pivot_wider(names_from = target_name, values_from = presente, values_fill = 0)

mat <- as.data.frame(binaria)
rownames(mat) <- mat$query_name
mat$query_name <- NULL

pdf("C:/Users/gabri/Documents/SCRIPTS_ESTUDIO_PYTHON/TRANSPORTADORES/data_proteomas/analisis_filogenia/hmmscan_resultados/upset_transportadores.pdf", width = 12, height = 8)
upset(mat, order.by = "freq", text.scale = 1.3)
dev.off()

cat("\nâœ… AnÃ¡lisis completado.\n")
PASO 3: Recomendaciones opcionales adicionales
âœ… Puedes agregar grÃ¡ficos por familia usando facet_wrap(Familia) si te interesa la separaciÃ³n por grupo funcional
âœ… PodrÃ­as hacer un PCA de presencia/ausencia, para visualizar agrupamientos de especies por perfil de dominios
âœ… Si quieres ir mÃ¡s lejos, un anÃ¡lisis de redes de co-ocurrencia de dominios usando igraph es muy elegante, dime y te lo armo

ğŸ”§ RESUMEN DE ARCHIVOS ESPERADOS
Archivo	CÃ³mo se genera
*.tblout	Salida bruta de hmmscan
pfam_transportadores.csv	Script Python de limpieza y combinaciÃ³n
GrÃ¡ficos .pdf y matrices .csv	Script en R de anÃ¡lisis posterior
==================================
==================================
==================================
==================================
==================================
âœ… Â¿QuÃ© hace exactamente el script?
âœ” Lee tu archivo .csv con resultados de hmmscan para transportadores.
âœ” Identifica la familia de cada proteÃ­na.
âœ” Para cada familia:
â€ƒâ—¾ Calcula los 7 dominios con mejor soporte (por promedio de score_full).
â€ƒâ—¾ Genera la matriz binaria de presencia/ausencia solo de esos 7 dominios.
â€ƒâ—¾ Calcula las combinaciones frecuentes de dominios (con tus filtros de mÃ­nimo 3 proteÃ­nas, mÃ¡ximo 10 combinaciones).
â€ƒâ—¾ Genera y guarda:
â€ƒâ€ƒâœ” CSV con la matriz binaria filtrada.
â€ƒâ€ƒâœ” CSV con las combinaciones frecuentes.
â€ƒâ€ƒâœ” Objeto .RData con todo por si quieres cargarlo despuÃ©s.
â€ƒâ€ƒâœ” GrÃ¡fico UpSetPlot bonito y limpio, con colores, tÃ­tulo y resumen informativo.
DescripciÃ³n del UpSetPlot generado
Se generaron grÃ¡ficos de tipo UpSetPlot para visualizar la ocurrencia y coocurrencia de dominios Pfam dentro de proteÃ­nas de cada familia de transportadores analizada. Este enfoque permite identificar combinaciones frecuentes de dominios estructurales en el contexto de la diversidad funcional de los transportadores.

Para cada familia:

âœ” Se seleccionaron los siete dominios con mayor soporte, determinado a partir del promedio del score HMM (score_full) obtenido en el escaneo con hmmscan.
âœ” Se construyÃ³ una matriz binaria de presencia/ausencia, representando la ocurrencia de dichos dominios en cada proteÃ­na de la familia.
âœ” El UpSetPlot visualiza:
â€ƒâ—¾ En la parte inferior: las combinaciones especÃ­ficas de dominios presentes en las proteÃ­nas.
â€ƒâ—¾ En la parte superior: el tamaÃ±o de la intersecciÃ³n, es decir, cuÃ¡ntas proteÃ­nas comparten exactamente esa combinaciÃ³n de dominios.
âœ” Las barras horizontales a la izquierda indican el tamaÃ±o total de cada conjunto (dominio).
âœ” Los colores asociados a cada dominio permiten facilitar la interpretaciÃ³n visual.

AdemÃ¡s, se incluyÃ³ informaciÃ³n complementaria como:

El nÃºmero total de proteÃ­nas analizadas por familia.

La cantidad de proteÃ­nas incluidas en el grÃ¡fico, correspondiente a aquellas que presentan combinaciones frecuentes segÃºn los umbrales establecidos.

El total de dominios considerados.

Este tipo de visualizaciÃ³n facilita la detecciÃ³n de patrones conservados o recurrentes en la arquitectura de dominios, lo que puede sugerir posibles relaciones funcionales o evolutivas dentro de cada familia de transportadores.

Resumen tÃ©cnico breve para mÃ©todos (si necesitas algo tipo paper):
"Se generaron grÃ¡ficos UpSetPlot por familia de transportadores utilizando los siete dominios Pfam con mayor soporte (mayor score HMM promedio). Se visualizaron las combinaciones frecuentes de dichos dominios, permitiendo identificar patrones recurrentes de coocurrencia funcional."


âœ… Es solo para los UpSetPlot
==================================
==================================
==================================
==================================
==================================
==================================
